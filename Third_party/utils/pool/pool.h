/**
\file pool.h
\brief A generic memory pool allocator.
*/

#ifndef POOL_H
#define POOL_H

#include <stddef.h>
#include <stdbool.h>
#include "slist.h"

/**
\brief Generates the pool api
\param name a name for the api with the given type and size
\param type the type of objects to allocate
\param size the maximum number of objects that can be allocated
*/
#define POOL(name, type, size)                                                  \
union pool_##name##_private {                                                   \
    struct slist_element element;                                               \
    type data;                                                                  \
};                                                                              \
struct pool_##name {                                                            \
    struct slist free_list;                                                     \
    union pool_##name##_private items[size];                                    \
};                                                                              \
static inline int pool_##name##_init(struct pool_##name *self) {                \
    if (!self) return -1;                                                       \
    slist_init(&self->free_list);                                               \
    for (size_t i = 0; i < size; ++i) {                                         \
        slist_prepend(&self->free_list, &self->items[i].element);               \
    }                                                                           \
    return 0;                                                                   \
}                                                                               \
static inline type *pool_##name##_alloc(struct pool_##name *self) {             \
    if (!self) return NULL;                                                     \
    struct slist_element *head;                                                 \
    if (slist_remove_head(&self->free_list, &head))                             \
        return NULL;                                                            \
    union pool_##name##_private *item = (union pool_##name##_private *)         \
        (((char *)head) - offsetof(union pool_##name##_private, element));      \
    return &item->data;                                                         \
}                                                                               \
static inline void pool_##name##_free(struct pool_##name *self, type *obj) {    \
    if (!self || !obj) return;                                                  \
    union pool_##name##_private *item = (union pool_##name##_private *)         \
        (((char *)obj) - offsetof(union pool_##name##_private, data));          \
    slist_prepend(&self->free_list, &item->element);                            \
}

#ifdef DOXYGEN
POOL(NAME, TYPE, SIZE);
/**
\struct pool_NAME
\brief instance type generated by \ref POOL with \c name set to \a NAME, \c type set to \a TYPE, and \c size set to \a SIZE

\var pool_NAME::free_list 
\brief the free list for \ref pool_NAME

\var pool_NAME::items 
\brief array of items from which to allocate of size \a SIZE

\union pool_NAME_private
\brief private instance type generated by \ref POOL with \c name set to \a NAME, \c type set to \a TYPE, and \c size set to \a SIZE
\details this type is used to store user data of type \a TYPE or an object of type \ref slist_element for linking objects onto the free list

\var pool_NAME_private::element 
\brief the \c free_list element

\var pool_NAME_private::data 
\brief the user data object of type \a TYPE

\fn int pool_NAME_init(struct pool_NAME *self)
\brief init function generated by \ref POOL with \c name set to \a NAME, \c type set to \a TYPE, and \c size set to \a SIZE
\param self the \ref pool_NAME to initialize
\return 0 if successful

\fn TYPE *pool_NAME_alloc(struct pool_NAME *self)
\brief alloc function generated by \ref POOL with \c name set to \a NAME, \c type set to \a TYPE, and \c size set to \a SIZE
\param self the \ref pool_NAME from which to allocate
\return pointer to \c TYPE if successful, \c NULL if not successful

\fn void pool_NAME_free(struct pool_NAME *self, TYPE *obj)
\brief free function generated by \ref POOL with \c name set to \a NAME, \c type set to \a TYPE, and \c size set to \a SIZE
\param self the \ref pool_NAME from which to allocate
\param obj the object to return to the pool \p self
*/
#endif

#endif //POOL_H